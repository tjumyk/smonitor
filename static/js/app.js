// Generated by CoffeeScript 1.12.7
(function() {
  var app;

  app = angular.module('app', []);

  app.controller('MainController', [
    '$scope', '$http', '$timeout', function($scope, $http, $timeout) {
      var human_size, percent_level, process_info_message, process_status_message;
      human_size = function(size) {
        var unit_pos, units;
        units = ['B', 'KB', 'MB', 'GB', 'TB'];
        unit_pos = 0;
        while (size >= 1000 && unit_pos < units.length - 1) {
          size /= 1024.0;
          unit_pos += 1;
        }
        if (size < 1) {
          size = Math.round(size * 100) / 100;
        } else {
          size = Math.round(size * 10) / 10;
        }
        return "" + size + units[unit_pos];
      };
      percent_level = function(percent) {
        if (percent < 80) {
          return '';
        }
        if (percent < 90) {
          return 'warning';
        }
        return 'danger';
      };
      process_info_message = function(info) {
        var gpu, i, len, ref;
        if (info.error) {
          return info;
        }
        info.memory.total_h = human_size(info.memory.total);
        if (info.disk.system) {
          info.disk.system.total_h = human_size(info.disk.system.total);
        } else {
          info.disk.system = {
            total_h: 'N/A'
          };
        }
        if (info.disk.others) {
          info.disk.others.total_h = human_size(info.disk.others.total);
        } else {
          info.disk.others = {
            total_h: 'N/A'
          };
        }
        info.up_time = moment.unix(info.boot_time).toNow(true);
        if (info.gpu) {
          ref = info.gpu.devices;
          for (i = 0, len = ref.length; i < len; i++) {
            gpu = ref[i];
            gpu.memory.total_h = human_size(gpu.memory.total);
          }
        }
        return info;
      };
      process_status_message = function(status) {
        if (status.error) {
          return status;
        }
        if (status.disk.system) {
          status.disk.system.percent_h = status.disk.system.percent + '%';
          status.disk.system.percent_level = percent_level(status.disk.system.percent);
        } else {
          status.disk.system = {
            percent_h: 'N/A'
          };
        }
        if (status.disk.others) {
          status.disk.others.percent_h = status.disk.others.percent + '%';
          status.disk.others.percent_level = percent_level(status.disk.others.percent);
        } else {
          status.disk.others = {
            percent_h: 'N/A'
          };
        }
        status.cpu.percent_h = status.cpu.percent + '%';
        status.memory.percent_h = status.memory.percent + '%';
        status.cpu.percent_level = percent_level(status.cpu.percent);
        status.memory.percent_level = percent_level(status.memory.percent);
        return status;
      };
      return $http.get('api/config').then(function(response) {
        var config, host, host_group, host_map, i, j, len, len1, local_host, local_host_group, ref, ref1, socket;
        $scope.config = config = response.data;
        config.site_title = config.site_name + ' \u00B7 System Monitor';
        $scope.socket = socket = io({
          path: window.location.pathname + 'socket.io'
        });
        if (config.mode === 'app') {
          host_map = {};
          ref = config.host_groups;
          for (i = 0, len = ref.length; i < len; i++) {
            host_group = ref[i];
            ref1 = host_group.hosts;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              host = ref1[j];
              host_map[host.name] = host;
            }
          }
          socket.on('info', function(message) {
            return $timeout(function() {
              var info_message, name, results;
              results = [];
              for (name in message) {
                info_message = message[name];
                results.push(host_map[name].info = process_info_message(info_message));
              }
              return results;
            });
          });
          return socket.on('status', function(message) {
            return $timeout(function() {
              var name, results, status_message;
              results = [];
              for (name in message) {
                status_message = message[name];
                results.push(host_map[name].status = process_status_message(status_message));
              }
              return results;
            });
          });
        } else {
          local_host = {
            name: 'local',
            address: 'localhost'
          };
          local_host_group = {
            name: 'Local Node',
            hosts: [local_host]
          };
          config.host_groups = [local_host_group];
          socket.on('info', function(message) {
            return $timeout(function() {
              return local_host.info = process_info_message(message);
            });
          });
          return socket.on('status', function(message) {
            return $timeout(function() {
              return local_host.status = process_status_message(message);
            });
          });
        }
      });
    }
  ]);

}).call(this);

//# sourceMappingURL=app.js.map
